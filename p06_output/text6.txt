\newpage
\section{Portability, Dependencies and Packaging}

\subsection{Appliaction Binary Interface (ABI)}

\begin{itemize}
    \item most Windows laptops, Linux laptops and pre-M1 Macs share the same ISA: \texttt{x86\_64}
    \item iPhones, Android phones, M1 and M2 Macs share the same ISA: \texttt{AArch64}
\end{itemize}

\textbf{Q:} Why, then, do applications need to be recompiled separately for each platform?\\
e.g., iPhone vs. Android phone

\textbf{A:} Because platforms have different OSs and ABIs.
\subsubsection{What is an ABI?}

An application binary interfaces (ABI) defines:
\begin{itemize}
    \item file format for
    \begin{itemize}
        \item object files
        \item dynamically-linked files (shared objects / dll)
        \item and executable files
    \end{itemize}
    \item convention for function calls
    \item convention for system calls
\end{itemize}

It is called binary because it is independent of the language in which applications are written (i.e., it is related to the machine code, not to the source code)

\subsubsection{ABI: function calls (x86\_64)}

\paragraph{ABI: function calls (x86\_64)}

The Application Binary Interface (ABI) for function calls within the x86\_64 architecture is exemplified by a simple C program that makes a call to the \texttt{puts} function. The assembly code generated by the \texttt{clang} compiler on Linux and the Microsoft Visual C++ (MSVC) compiler on Windows shows the differences in calling conventions and assembly syntax.

For \textbf{clang/Linux/x86\_64}, the assembly instructions prepare the function argument by loading the address of the string into \texttt{rdi}, which is the register for the first argument as per the calling convention. It then calls \texttt{puts} and exits the program with a return value of 0.

For \textbf{MSVC/Windows/x86\_64}, the assembly code shows the Windows calling convention where the string address is placed into the \texttt{rcx} register, and then the \texttt{puts} function is called. After the function call, the stack is cleaned up and the program returns.

\paragraph{ABI: function calls (AArch64)}

In the case of the AArch64 architecture, the C program remains the same, but the assembly output changes significantly to reflect the different register and calling convention.

For \textbf{clang/MacOS/AArch64}, the assembly output uses the \texttt{stp} instruction to store pair of registers and the \texttt{adrp} and \texttt{add} instructions to form the address of the string. The first argument is moved into the \texttt{x0} register before the \texttt{puts} call is made.

For \textbf{MSVC/Windows/AArch64}, similar to the clang/MacOS assembly, we see the use of \texttt{stp} for storing register pairs and \texttt{adrp} plus \texttt{add} to handle the string address. The \texttt{puts} function is then called with the argument in \texttt{x0}, followed by the function's exit sequence.

\texttt{Try it for yourself: godbolt.org}

\subsection{Portable Code}

How do we ship code that work across all platforms?


\subsubsection{Option 1: interpreters}
\begin{itemize}
  \item use interpreted languages, ship source
  \begin{itemize}
    \item Python, Javascript, \ldots
  \end{itemize}
  \item languages that compile to virtual machine code
  \begin{itemize}
    \item ship VM code
    \item optionally, ship VM interpreter
    \item Java, C\#
  \end{itemize}
\end{itemize}

\subsubsection{Option 2: multiple compilations}
\begin{itemize}
  \item compile one executable on each platform
  \item in some cases, cross-compilation is possible
  \begin{itemize}
    \item MacOS $\rightarrow$ iOS
    \item Linux $\rightarrow$ Android
  \end{itemize}
\end{itemize}

\paragraph{What if we cannot (or do not want to) recompile?}


\subsubsection{Option 3: Translation}
\textbf{Use case:} same OS, different ISA
\begin{itemize}
    \item Translation is a form of compilation
    \item From machine code
    \item To machine code (of a different ISA)
\end{itemize}
\textit{Example: Apple Rosetta 2 translates \texttt{x86\_64} into \texttt{AArch64}}

\subsubsection{Option 4: Compatibility layers}
\textbf{Use case:} different OSs, same ISA
\begin{itemize}
    \item add OS support for a foreign ABI
    \begin{itemize}
        \item foreign file formats (for objects, DLLs and executables)
        \item foreign convention for system calls
    \end{itemize}
    \item add libraries for foreign ABI
    \begin{itemize}
        \item foreign convention for function calls
    \end{itemize}
    \item Examples:
    \begin{itemize}
        \item Wine allows running Windows apps on Linux.
        \item WSLv1 allows running Linux apps on Windows.
    \end{itemize}
\end{itemize}

\subsubsection{Option 5: emulation}
\begin{itemize}
    \item an emulator is an \textbf{interpreter} for machine code (e.g. QEmu)
    \item much slower than running the code
    \item JIT can mitigate slowness, to some extent
    \item typically, a full-blown \textbf{operating system} runs inside the interpreter!
\end{itemize}

\subsubsection{Option 6: virtualization}

\begin{itemize}
    \item virtualization is essentially hardware-assisted emulation \\
    (e.g., Xen, KVM, VirtualBox, VMware, Apple Parallels, WSLv2)
    \item virtualized software must target the same ISA as hardware
    \item like emulation, runs a full-blown \textbf{operating system}
\end{itemize}


\subsubsection{Definitions}

\begin{itemize}
  \item The \textbf{hypervisor} is the software that manages the \textbf{guest OS}.
  \item It can be the \textbf{host OS} itself (``Type 1": Xen, KVM)
  \item It can be a process within the \textbf{host OS} (``Type 2": Apple Parallels)
\end{itemize}

Virtualization is mainly deals with security:

Let \textbf{guest OSs} believe they have direct access to hardware...

... but every hardware access is tightly controlled by the \textbf{hypervisor}

\paragraph{Virtualization is the main technology enabling ``cloud computing''.}

\begin{itemize}
  \item Amazon Web Services runs \textbf{Xen}
  \item Google Cloud Platform runs \textbf{KVM}
  \item Customers rent a virtual machine in a datacenter
  \begin{itemize}
    \item They can connect (remotely) to this machine
    \item It runs their (\textbf{guest}) OS of choice
    \item It acts as if it was physical hardware
  \end{itemize}
\end{itemize}

\subsubsection{Option 7: containers}
\textbf{Use case:} Same ISA, same kernel, different OS.

\begin{itemize}
  \item Containers are a lightweight form of virtualization.
  \item The host's kernel also acts as a kernel for the guest.
  \item Mainly: filesystems, libraries and applications are separated.
\end{itemize}

\textbf{Examples:}
\begin{itemize}
  \item A Debian Linux guest on a Fedora Linux host
  \item A Debian 11 Linux guest on a Debian 12 host
  \item A Debian 12 guest with specific libraries installed, on a Debian 12 host
\end{itemize}

\subsection{Application Programming Interfaces (API)}

\subsubsection{Definition}
An API defines how a library (or any other service) is to be used.


\subsubsection{Library API}

\verb|FILE *fopen(const char *path, const char *mode);|

\verb|open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closedfd=True, opener=None)|

\subsubsection{Web API}

\verb|GET https://www.google.com/search?q=<query>|

\paragraph{Example:}

\verb|google-chrome https://www.google.com/search?q=Software%20Engineering|

\verb|GET https://cloudflare.com/cdn-cgi/trace|

\paragraph{Example:}

\verb|curl -s "https://cloudflare.com/cdn-cgi/trace"|
\texttt{PUT https://api.cloudflare.com/client/v4/zones/\{zone\_identifier\}/dns\_records/\{identifier\}}

\begin{verbatim}
curl --request PUT \
     --url https://api.cloudflare.com/client/v4/zones/zone_identifier/dns_records/identifier \
     --header 'Content-Type: application/json' \
     --header 'X-Auth-Email: ' \
     --data '{
       "content": "198.51.100.4",
       "name": "example.com",
       "proxied": false,
       "type": "A",
       "comment": "Domain verification record",
       "tags": [
         "owner: dns-team"
       ],
       "ttl": 3600
     }'
\end{verbatim}
\subsubsection{APIs and portability}
\begin{itemize}
  \item many APIs are cross-platform
  \begin{itemize}
    \item C standard library
    \item Almost all Python modules
    \item Qt, Electron, Flutter, \ldots (frameworks for GUI applications)
    \item WEB APIs only depend on an internet connection
  \end{itemize}
  \item some are specific to a platform
  \begin{itemize}
    \item Windows UI Library, MacOS Cocoa
  \end{itemize}
\end{itemize}
\subsection{Dependencies}

\renewcommand{\labelitemii}{$\star$}
\begin{itemize}
  \item your code requires libA version $ \geq 1.1$, lib B version $ \geq 4.5$
  \begin{itemize}
    \item lib B version 4.5 requires libX version 2.0 and libA version 0.8
    \item lib B version 4.7 requires libX version 2.0 and libA version 1.1
    \item lib B version 4.6 requires libX version 2.0 and libA version 2.0
    \item lib X version 2.0 requires libA version $ \leq 1.9$
  \end{itemize}
  How do we install all this? \\
  Which version do we install?
\end{itemize}

\subsubsection{Package managers}

Package managers solve this problem for you. \\
They can solve it...

\begin{itemize}
  \item at the OS level:
  \begin{itemize}
    \item MacOS: \texttt{brew install <package>}
    \item Debian/Ubuntu Linux: \texttt{apt-get install <package>}
    \item Fedora/Suse Linux: \texttt{dnf install <package>}
  \end{itemize}
  \item at the language level:
  \begin{itemize}
    \item Python: \texttt{pip install <module>}
    \item JavaScript/Node: \texttt{npm install <package>}
  \end{itemize}
\end{itemize}

\subsubsection{Limitations}

\begin{itemize}
  \item package selection may be limited (packaging is labor-intensive)
  \item security and trust
\end{itemize}


\subsubsection{Tutorial: Treating Integers as Strings of Bits in python}
\begin{itemize}
    \item \textbf{OR Operation:} The bitwise OR (\texttt{\textbar}) combines bits such that the bit in the result is 1 if either bit is 1.
    \begin{verbatim}
    >>> x = 0b110000 | 0b000011
    >>> f"{x:06b}"  # '110011'
    \end{verbatim}

    \item \textbf{AND Operation:} The bitwise AND (\texttt{\&}) combines bits with a result of 1 only if both bits are 1.
    \begin{verbatim}
    >>> x = 0b111100 & 0b001111
    >>> f"{x:06b}"  # '001100'
    \end{verbatim}

    \item \textbf{XOR Operation:} The bitwise XOR (\texttt{\textasciicircum}) combines bits with a result of 1 only if the bits are different.
    \begin{verbatim}
    >>> x = 0b101010 ^ 0b110011
    >>> f"{x:06b}"  # '011001'
    \end{verbatim}

    \item \textbf{Left Shift Operation:} Shifts bits to the left, filling in with zeros (\texttt{<<}).
    \begin{verbatim}
    >>> x = 0b000110 << 2
    >>> f"{x:06b}"  # '011000'
    \end{verbatim}

    \item \textbf{Right Shift Operation:} Shifts bits to the right, discarding excess bits (\texttt{>>}).
    \begin{verbatim}
    >>> x = 0b011000 >> 2
    >>> f"{x:06b}"  # '000110'
    \end{verbatim}
\end{itemize}